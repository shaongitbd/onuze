import uuid
from django.db import models
from django.utils import timezone
from django.db.models import F
from users.models import User
from posts.models import Post
from comments.models import Comment



class Vote(models.Model):
    """
    Vote model for tracking upvotes and downvotes on posts and comments.
    Uses polymorphic relationship for content_type and content_id.
    """
    # Vote types
    DOWNVOTE = -1
    UPVOTE = 1
    VOTE_TYPES = [
        (DOWNVOTE, 'Downvote'),
        (UPVOTE, 'Upvote'),
    ]
    
    # Content types
    POST = 'post'
    COMMENT = 'comment'
    CONTENT_TYPES = [
        (POST, 'Post'),
        (COMMENT, 'Comment'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='votes')
    content_type = models.CharField(max_length=50, choices=CONTENT_TYPES)
    content_id = models.UUIDField()
    vote_type = models.SmallIntegerField(choices=VOTE_TYPES)
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'vote'
        verbose_name = 'Vote'
        verbose_name_plural = 'Votes'
        # Ensure one vote per user per content
        unique_together = ('user', 'content_type', 'content_id')
        indexes = [
            models.Index(fields=['content_type', 'content_id']),
            models.Index(fields=['user', 'content_type']),
        ]
    
    def __str__(self):
        vote_label = 'upvote' if self.vote_type == self.UPVOTE else 'downvote'
        return f"{self.user.username}'s {vote_label} on {self.content_type} {self.content_id}"
    
    def save(self, *args, **kwargs):
        # Track if this is a new vote or an update
        # Use _state.adding instead of self.pk is None to correctly detect new objects
        is_new = self._state.adding
        print(f"In save(): is_new={is_new}, pk={self.pk}, _state.adding={self._state.adding}")
        
        if not is_new:
            try:
                old_instance = Vote.objects.get(pk=self.pk)
                old_vote_type = old_instance.vote_type
            except Vote.DoesNotExist:
                print(f"Warning: Could not find Vote with pk={self.pk} in database, treating as new")
                is_new = True
                old_vote_type = None
        else:
            old_vote_type = None
        
        # Save the vote first before any other operations
        self.updated_at = timezone.now()
        print(f"About to call super().save() with is_new={is_new}")
        super().save(*args, **kwargs)
        print(f"super().save() completed, new pk={self.pk}")
        
        # Now do the post-save operations with error handling
        try:
            # Update the vote counts on the content
            self._update_content_vote_counts(is_new, old_vote_type)
        
            # Update user karma (without checking hasattr)
            if self.content_type == self.POST:
                # Karma impact is higher for posts
                self._update_user_karma(is_new, old_vote_type, multiplier=2)
            else:
                self._update_user_karma(is_new, old_vote_type)
        except Exception as e:
            print(f"Error in post-save operations, but vote was saved: {e}")
            # Don't re-raise the exception since we want the vote to be saved regardless
    
    def delete(self, *args, **kwargs):
        # Store vote info before deletion
        vote_type = self.vote_type
        
        super().delete(*args, **kwargs)
        
        # Update content vote counts after deletion
        self._update_content_vote_counts(is_new=False, old_vote_type=vote_type, is_deletion=True)
        
        # Update user karma
        self._update_user_karma(is_new=False, old_vote_type=vote_type, is_deletion=True)
    
    def _update_content_vote_counts(self, is_new, old_vote_type, is_deletion=False):
        """Update vote counts on the content (post or comment)."""
        print(f"_update_content_vote_counts called: is_new={is_new}, old_vote_type={old_vote_type}, is_deletion={is_deletion}, self.vote_type={self.vote_type}")
        
        try:
            if self.content_type == self.POST:
                try:
                    print(f"Getting post with id={self.content_id}")
                    post = Post.objects.get(id=self.content_id)
                    
                    # Calculate updated vote counts
                    upvotes = max(0, post.upvote_count)  # Ensure non-negative
                    downvotes = max(0, post.downvote_count)  # Ensure non-negative
                    print(f"Current post votes: up={upvotes}, down={downvotes}")
                    
                    if is_deletion:
                        # Removing a vote
                        if old_vote_type == self.UPVOTE:
                            upvotes = max(0, upvotes - 1)  # Ensure non-negative
                        elif old_vote_type == self.DOWNVOTE:
                            downvotes = max(0, downvotes - 1)  # Ensure non-negative
                    elif is_new:
                        # Adding a new vote
                        if self.vote_type == self.UPVOTE:
                            upvotes += 1
                            print(f"Adding upvote, new upvotes={upvotes}")
                        elif self.vote_type == self.DOWNVOTE:
                            downvotes += 1
                            print(f"Adding downvote, new downvotes={downvotes}")
                    else:
                        # Changing vote type
                        if old_vote_type == self.UPVOTE and self.vote_type == self.DOWNVOTE:
                            upvotes = max(0, upvotes - 1)  # Ensure non-negative
                            downvotes += 1
                        elif old_vote_type == self.DOWNVOTE and self.vote_type == self.UPVOTE:
                            downvotes = max(0, downvotes - 1)  # Ensure non-negative
                            upvotes += 1
                    
                    print(f"New post votes: up={upvotes}, down={downvotes}")
                    
                    # Update the post
                    print(f"Calling post.update_vote_counts({upvotes}, {downvotes})")
                    post.update_vote_counts(upvotes, downvotes)
                    print(f"After update_vote_counts, post has: up={post.upvote_count}, down={post.downvote_count}")
                
                except Post.DoesNotExist:
                    print(f"Post with id={self.content_id} not found!")
                    pass  # Post may have been deleted
                except Exception as e:
                    print(f"Error updating post vote counts: {e}")
                
            elif self.content_type == self.COMMENT:
                try:
                    comment = Comment.objects.get(id=self.content_id)
                    
                    # Calculate updated vote counts
                    upvotes = max(0, comment.upvote_count)  # Ensure non-negative
                    downvotes = max(0, comment.downvote_count)  # Ensure non-negative
                    
                    if is_deletion:
                        # Removing a vote
                        if old_vote_type == self.UPVOTE:
                            upvotes = max(0, upvotes - 1)  # Ensure non-negative
                        elif old_vote_type == self.DOWNVOTE:
                            downvotes = max(0, downvotes - 1)  # Ensure non-negative
                    elif is_new:
                        # Adding a new vote
                        if self.vote_type == self.UPVOTE:
                            upvotes += 1
                        elif self.vote_type == self.DOWNVOTE:
                            downvotes += 1
                    else:
                        # Changing vote type
                        if old_vote_type == self.UPVOTE and self.vote_type == self.DOWNVOTE:
                            upvotes = max(0, upvotes - 1)  # Ensure non-negative
                            downvotes += 1
                        elif old_vote_type == self.DOWNVOTE and self.vote_type == self.UPVOTE:
                            downvotes = max(0, downvotes - 1)  # Ensure non-negative
                            upvotes += 1
                    
                    # Update the comment
                    comment.update_vote_counts(upvotes, downvotes)
                    
                except Comment.DoesNotExist:
                    pass  # Comment may have been deleted
                except Exception as e:
                    print(f"Error updating comment vote counts: {e}")
                    
        except Exception as e:
            print(f"Unhandled error in _update_content_vote_counts: {e}")
            # Don't re-raise, we want the vote to be saved regardless
    
    def _update_user_karma(self, is_new, old_vote_type, multiplier=1, is_deletion=False):
        """Update the user's karma based on the vote."""
        try:
            # Get the author of the content
            if self.content_type == self.POST:
                content_author = Post.objects.get(id=self.content_id).user
            elif self.content_type == self.COMMENT:
                content_author = Comment.objects.get(id=self.content_id).user
            else:
                return  # Unknown content type
            
            # Skip if voting on own content
            if content_author == self.user:
                return
            
            # Calculate karma change
            karma_change = 0
            
            if is_deletion:
                # Removing a vote
                if old_vote_type == self.UPVOTE:
                    karma_change = -1 * multiplier
                elif old_vote_type == self.DOWNVOTE:
                    karma_change = 1 * multiplier
            elif is_new:
                # Adding a new vote
                if self.vote_type == self.UPVOTE:
                    karma_change = 1 * multiplier
                elif self.vote_type == self.DOWNVOTE:
                    karma_change = -1 * multiplier
            else:
                # Changing vote type
                if old_vote_type == self.UPVOTE and self.vote_type == self.DOWNVOTE:
                    karma_change = -2 * multiplier
                elif old_vote_type == self.DOWNVOTE and self.vote_type == self.UPVOTE:
                    karma_change = 2 * multiplier
            
            # Update the user's karma
            if karma_change > 0:
                content_author.increment_karma(amount=karma_change)
            elif karma_change < 0:
                content_author.decrement_karma(amount=abs(karma_change))
                
        except (Post.DoesNotExist, Comment.DoesNotExist):
            pass  # Content may have been deleted
    
    @property
    def post(self):
        """Get the related post if content_type is POST."""
        if self.content_type == self.POST:
            try:
                return Post.objects.get(id=self.content_id)
            except Post.DoesNotExist:
                return None
        return None
    
    @property
    def comment(self):
        """Get the related comment if content_type is COMMENT."""
        if self.content_type == self.COMMENT:
            try:
                return Comment.objects.get(id=self.content_id)
            except Comment.DoesNotExist:
                return None
        return None
    
    @classmethod
    def create_or_update(cls, user, content_type, content_id, vote_type):
        """Create a new vote or update an existing one."""
        print(f"create_or_update called: user={user.id}, content_type={content_type}, content_id={content_id}, vote_type={vote_type}")
        try:
            vote = Vote.objects.get(
                user=user,
                content_type=content_type,
                content_id=content_id
            )
            print(f"Found existing vote: {vote.id}")
            
            # If vote type is the same, remove the vote (toggle)
            if vote.vote_type == vote_type:
                print(f"Deleting vote {vote.id} (toggle behavior)")
                vote.delete()
                return None
            else:
                print(f"Updating vote {vote.id} from {vote.vote_type} to {vote_type}")
                vote.vote_type = vote_type
                vote.updated_at = timezone.now()
                vote.save()
                return vote
                
        except:
            # Create a new vote
            print("No existing vote found, creating new one")
            try:
                vote = Vote(
                    user=user,
                    content_type=content_type,
                    content_id=content_id,
                    vote_type=vote_type
                )
                print(f"Created vote object, about to save: {vars(vote)}")
                vote.save()
                print(f"Vote saved successfully! New ID: {vote.id}")
                return vote
            except Exception as e:
                print(f"ERROR SAVING VOTE: {str(e)}")
                # Let's print the object details
                for key, value in vars(vote).items():
                    print(f"  {key}: {value} (type: {type(value)})")
                raise
        
            
